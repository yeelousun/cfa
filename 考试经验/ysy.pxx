import json
import os
import sys

import numpy as np
from api_caller import APICaller
from PySide6.QtWidgets import (
    QApplication,
    QFileDialog,
    QHBoxLayout,
    QLineEdit,
    QListWidget,
    QMainWindow,
    QMessageBox,
    QProgressBar,
    QPushButton,
    QSizePolicy,
    QTableWidget,
    QTableWidgetItem,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)
from utils import Config

# api
api_config = Config()
api_config._set_azure_openai_endpoint("xxx")
api_c = APICaller(api_config)


system_prompt = """
【役割設定】
あなたはメインフレームシステム(z/OS)のJCL専門家です。Job Control Language
の解析、最適化、自動処理に特化しており、JCLの構文規則、IBM標準プロセス、一般的なジョブスケジューリングシナリオに精通しています。

【コア能力】
1. 構造化解析
- JCLジョブを論理コンポーネント(JOB/EXEC/DDステートメント)に自動分割
- COBOL/PROC/シンボリックパラメータなどのネスト構造を識別
- キーパラメータ(DSN、DISP、SPACEなど)を注釈付け

2. インテリジェント処理
- ジョブフローのチャンキング(EXECステップごとに分割)
- データセットの依存関係分析
- 条件コード/JOBRCの検証ロジック解析
- リソース要件の推定(REGION、TIMEなど)

3. セキュリティ規範
- 機密情報(本番データセット名など)の自動マスキング
- 潜在的な問題の注釈付け(未解放データセット/重複DD名)
- ABEND処理ロジックの完全性チェック
"""

JCL_comment_prompt = """
JCLコード:
{code}
上記のJCLコードの機能、内容は2文の要約にしてください
"""
JCL_seg_prompt = """
JCLコード:
{code}

上記のJCLコードは実行コードと説明コメント二つ部分構成する
"//*"スタートの行は説明コメント文字です
"//*"以外スタートの行は実行コードです

タスクはJCLコードは機能よって分割して、
分割されたコードとコードの説明コメントをセットとして作成する

分割されたコードの完全性を確認して、元コード中に漏れないで、
コードの説明は元コード中に既存のコメントを参照してください

出力フォマードはJSONです
例えば：
{{
"code_segments":[
{{"code":"コード内容1","description":"コード内容1の説明"}},
{{"code":"コード内容2","description":"コード内容2の説明"}},
...
]
}}

"""

RAG_prompt = """
検索された情報とユーザーの質問を組み合わせ、詳細かつ専門的な回答を作成してください。

【ユーザーの質問】
{q_text}

【検索された情報】
{r_text}

【タスク要求】
上記の検索された情報とその説明に基づき、ユーザーの質問を踏まえて、詳細かつ専門的な回答を作成してください。
- 回答中には、可能な限り対応するコードや説明を引用してください。
- 提供された情報だけでは質問に完全に回答できない場合、その情報不足の部分を明記し、あなたの専門知識を基に合理的な推測や補足を行ってください。
- 現在のユーザーの質問が意味不明または不明瞭であると判断した場合、回答中にその旨を指摘し、ユーザーに再度質問するよう促してください。
  同時に、現在のユーザーの質問に基づいて、3つの可能性のある、より明確な質問を生成し、ユーザーが更に要求を明確にできるよう支援してください。
- 回答は、論理が明快で、言語が専門的であることを求められ、必要に応じて最適化または改善の提案を行ってください。

【回答】
"""


# emb
@staticmethod
def get_emb(sentence):
    response = api_c.request_embedding(sentence)
    try:
        if isinstance(response, list):
            vector = tuple(response)
    except Exception as e:
        raise e
    return vector


# gpt
@staticmethod
def get_completion(prompt, t, j):
    response = api_c.request_chat_completion_k(system_prompt, prompt, t, j)
    try:
        if isinstance(response, str):
            pass
    except Exception as e:
        raise e
    return response


# cos
@staticmethod
def cosine_distance(v1, v2):
    """ """
    v1 = np.array(v1)
    v2 = np.array(v2)
    norm_v1 = np.linalg.norm(v1)
    norm_v2 = np.linalg.norm(v2)
    # avoid zero
    if norm_v1 == 0 or norm_v2 == 0:
        return 1.0
    cosine_sim = np.dot(v1, v2) / (norm_v1 * norm_v2)
    return cosine_sim


@staticmethod
def init_k_db(k_dict, idx):
    if idx not in k_dict:
        k_dict[idx] = {
            "name": "",
            "type": "",
            "code": "",
            "code_emb": [],
            "comment": "",
            "comment_emb": [],
        }
    else:
        print(f"over idx {idx}")
        raise
    return k_dict


@staticmethod
def get_jcl_code(file_path):
    content = ""
    encodings = ["cp932", "utf-8"]
    for encoding in encodings:
        try:
            with open(file_path, "r", encoding=encoding) as f:
                content = f.read()
                break
        except UnicodeDecodeError:
            continue
    return content


class CollapsibleWidget(QWidget):
    """
    CollapsibleWidget
    """

    def __init__(self, title="", parent=None):
        super().__init__(parent)
        self.toggle_button = QPushButton(title)
        self.toggle_button.setCheckable(True)
        self.toggle_button.setChecked(True)
        self.toggle_button.clicked.connect(self.on_toggle)

        # sub widget
        self.content_area = QWidget()
        self.content_layout = QVBoxLayout(self.content_area)
        self.content_layout.setContentsMargins(0, 0, 0, 0)

        main_layout = QVBoxLayout(self)
        main_layout.addWidget(self.toggle_button)
        main_layout.addWidget(self.content_area)
        main_layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(main_layout)

    def on_toggle(self):
        if self.toggle_button.isChecked():
            self.content_area.show()
        else:
            self.content_area.hide()


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("検索デモ")
        # window size
        self.resize(800, 800)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setSpacing(10)

        # knowledge
        self.knowledge_area = CollapsibleWidget("JCLナレッジ作成")
        main_layout.addWidget(self.knowledge_area)
        self.init_knowledge_area()

        # search
        self.search_area = CollapsibleWidget("JCL検索")
        main_layout.addWidget(self.search_area)
        self.init_search_area()

        # param
        self.file_names = []
        self.knowledge_dict = {}
        self.knowledge_dict_path = "./knowledge_dict.json"

    def init_knowledge_area(self):
        """ """
        layout = self.knowledge_area.content_layout

        # 1. files
        self.select_file_button = QPushButton("JCLファイル")
        layout.addWidget(self.select_file_button)
        self.select_file_button.clicked.connect(self.select_files)

        # 2. paths
        self.file_list = QListWidget()
        layout.addWidget(self.file_list)

        # 3. knowledge
        h_layout = QHBoxLayout()
        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)
        h_layout.addWidget(self.progress_bar)

        self.execute_button = QPushButton("作成")
        h_layout.addWidget(self.execute_button)
        self.execute_button.clicked.connect(self.execute_task)

        layout.addLayout(h_layout)

    def init_search_area(self):
        """ """
        layout = self.bottom_area.content_layout

        # input
        input_layout = QHBoxLayout()
        self.input_text = QLineEdit()
        self.input_text.setPlaceholderText("検索内容入力...")
        input_layout.addWidget(self.input_text)

        self.search_button = QPushButton("検索")
        input_layout.addWidget(self.search_button)
        self.search_button.clicked.connect(self.search_action)
        layout.addLayout(input_layout)

        # result
        self.reply_text = QTextEdit()
        self.reply_text.setPlaceholderText("検索結果...")
        self.reply_text.setReadOnly(True)
        layout.addWidget(self.reply_text)

        # index and cos sim
        self.table = QTableWidget(0, 4)
        self.table.setHorizontalHeaderLabels(["番号", "ファイル", "種類", "類似度"])
        self.table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.table)

        # code and comment
        self.table.cellClicked.connect(self.show_detail)

    def select_files(self):
        """ """
        file_paths, _ = QFileDialog.getOpenFileNames(
            self, "JCLファイル", "", "JCL Files (*.JCL *.jcl)"
        )
        if file_paths:
            self.file_list.clear()
            self.file_list.addItems(file_paths)
            self.file_names = file_paths

    def execute_task(self):
        """
        1. read jcl file
        2. add all jcl code comment
        3. seg jcl code
        4. save knowledge dict
        5. get each embedding
        """
        self.progress_bar.setValue(0)
        self.progress = 0
        # check k dict
        if os.path.isfile(self.knowledge_dict_path):
            QMessageBox.warning(
                self, "warning", "既存ナレッジがあります、実行前に削除してください"
            )
            return
        if self.file_names:
            self.progress_value = int(50 / len(self.file_names))
        else:
            QMessageBox.warning(self, "warning", "ファイルを選択してください")
            return
        idx_no_num = 0
        for file_path in self.file_names:
            idx_no = str(idx_no_num)
            jcl_name = file_path.split("/")[-1]
            self.knowledge_dict = init_k_db(self.knowledge_dict, idx_no)
            self.knowledge_dict[idx_no]["name"] = jcl_name
            self.knowledge_dict[idx_no]["type"] = "all_code"
            self.knowledge_dict[idx_no]["code"] = get_jcl_code(file_path)
            self.knowledge_dict[idx_no]["code_emb"] = get_emb(
                self.knowledge_dict[idx_no]["code"]
            )
            self.knowledge_dict[idx_no]["comment"] = get_completion(
                JCL_comment_prompt.format(code=self.knowledge_dict[idx_no]["code"]),
                0.2,
                "text",
            )
            self.knowledge_dict[idx_no]["comment_emb"] = get_emb(
                self.knowledge_dict[idx_no]["comment"]
            )

            seg_code_dict = json.loads(
                get_completion(
                    JCL_seg_prompt.format(code=self.knowledge_dict[idx_no]["code"]),
                    0.2,
                    "json",
                )
            )
            self.update_progress()
            seg_code_list = list(seg_code_dict["code_segments"])
            for seg_code in seg_code_list:
                idx_no_num += 1
                idx_no = str(idx_no_num)
                self.knowledge_dict = init_k_db(self.knowledge_dict, idx_no)
                self.knowledge_dict[idx_no]["name"] = jcl_name
                self.knowledge_dict[idx_no]["type"] = "seg_code"
                self.knowledge_dict[idx_no]["code"] = seg_code["code"]
                self.knowledge_dict[idx_no]["code_emb"] = get_emb(
                    self.knowledge_dict[idx_no]["code"]
                )
                self.knowledge_dict[idx_no]["comment"] = seg_code["description"]
                self.knowledge_dict[idx_no]["comment_emb"] = get_emb(
                    self.knowledge_dict[idx_no]["comment"]
                )
            self.update_progress()
            idx_no += 1
        # save knowledge
        with open(self.knowledge_dict_path, "w", encoding="utf-8") as f:
            json.dump(self.knowledge_dict, f, ensure_ascii=False, indent=4)
        self.progress_bar.setValue(100)
        QMessageBox.information(self, "knowledge_dict", "ナレッジディクショナリー済み")
        self.knowledge_dict = {}

    def update_progress(self):
        self.progress += self.progress_value
        if self.progress > 100:
            self.progress_bar.setValue(100)
        else:
            self.progress_bar.setValue(self.progress)

    def search_action(self):
        """ """
        if self.knowledge_dict == {}:
            if os.path.isfile(self.knowledge_dict_path):
                QMessageBox.warning(
                    self,
                    "warning",
                    "既存ナレッジがない、最初にナレッジディクショナリーを作ってください",
                )
                return
            else:
                with open(self.knowledge_dict_path, "r", encoding="utf-8") as f:
                    self.knowledge_dict = json.load(f)

        text = self.input_text.text().strip()
        if not text:
            QMessageBox.warning(self, "warning", "検索内容を入力してください")
            return
        text_emb = get_emb(str(text))

        results = []
        for group_key, subdict in self.knowledge_dict.items():
            for sub_key in ["code_emb", "comment_emb"]:
                vec = subdict[sub_key]
                cossim = cosine_distance(text_emb, vec)
                results.append((group_key, cossim))

        results_sorted = sorted(results, key=lambda x: x[1], reverse=True)
        top5 = []
        # get top5 and r text , table
        self.table.setRowCount(0)
        retrieve_text = "\n"
        for res_sort in results_sorted:
            if res_sort[0] not in top5:
                top5.append(res_sort)
                # r text
                retrieve_text += f"コード番号:{res_sort[0]}\n"
                retrieve_text += (
                    f"コード:\n {self.knowledge_dict[res_sort[0]]['code']}\n"
                )
                retrieve_text += (
                    f"コード説明:\n {self.knowledge_dict[res_sort[0]]['comment']}\n"
                )
                retrieve_text += f"質問と類似度:{res_sort[1]}\n"
                retrieve_text += "\n"
                # table
                row_position = self.table.rowCount()
                self.table.insertRow(row_position)
                item1 = QTableWidgetItem(str(res_sort[0]))
                item2 = QTableWidgetItem(self.knowledge_dict[res_sort[0]]["name"])
                item3 = QTableWidgetItem(self.knowledge_dict[res_sort[0]]["type"])
                item4 = QTableWidgetItem(str(res_sort[1] * 100) + "%")
                self.table.setItem(row_position, 0, item1)
                self.table.setItem(row_position, 1, item2)
                self.table.setItem(row_position, 2, item3)
                self.table.setItem(row_position, 3, item4)

            if len(top5) > 4:
                break
        res_msg = get_completion(
            RAG_prompt.format(q_text=str(text), r_text=retrieve_text),
            0.6,
            "text",
        )
        self.reply_text.setText(res_msg)

    def show_detail(self, row, column):
        """ """
        knowledge_index = (
            self.table.item(row, 0).text() if self.table.item(row, 0) else ""
        )

        detail = f"コード：\n{self.knowledge_dict[knowledge_index]['code']}\n\nコメント: \n{self.knowledge_dict[knowledge_index]['comment']}\n"
        QMessageBox.information(self, "詳細", detail)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())
